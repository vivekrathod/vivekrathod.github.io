---
title: 'C++/CLI : Accessing managed types from unmanaged code'
date: 2011-06-21 18:35:00 Z
tags:
- Programming
- C++/CLI
layout: post
author: Vivek Rathod
modified_time: '2014-02-03T14:57:02.623-05:00'
blogger_id: tag:blogger.com,1999:blog-3203466822740858620.post-6244856322709101050
blogger_orig_url: https://blog.vivekrathod.com/2011/06/ccli-accessing-managed-types-from.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><table border="0" cellpadding="0" cellspacing="0" style="width: 100%px;"><tbody><tr><td id="MSOZoneCell_WebPartWPQ3" valign="top"><table border="0" cellpadding="0" cellspacing="0" style="width: 100%px;"><tbody><tr><td valign="top"><div id="WebPartWPQ3">I just found this long blog post I wrote at my work place last year - thought its worthwhile sharing it<br />Date: 1/21/2010<br /><br /><!-- Start Article --><span id="ArticleContent"></span><br /><h3 style="background-color: white; color: #333333; font-family: 'Helvetica Neue Light', HelveticaNeue-Light, 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 1.17em; font-weight: bolder; margin: 0.83em 0px; padding: 0px; removed: relative; text-align: justify;"><span id="ArticleContent"><span style="font-size: 11px; font-weight: normal;"></span></span></h3><h2><span id="ArticleContent">Introduction</span></h2><span id="ArticleContent">This article aspires to explain one of the ways a <em>managed type (/clr compiled)</em>&nbsp;can be used/invoked from a <em>native type (/clr compiled)&nbsp;</em>and more importantly from <em>unmanaged C/C++</em> <em>code</em>.<br /> </span><br /><h2><span id="ArticleContent">Background&nbsp;</span></h2><span id="ArticleContent">When I started dabbling in C++/CLI, I often got confused by these words like <em>managed code, unmanaged code, managed type, native types</em> etc, so for someone who happens to be in the same boat, lets try to get that out of the way. Simply put, m<em>anaged code</em>&nbsp;would be any code that is compiled with the <strong>/clr </strong>(and its variants like /clr:pure) flag, and&nbsp;<em>Unmanaged code</em>&nbsp;would be the one that is not compiled with /clr (or any of its variants). The concept of <em>managed and native types</em> applies to <em>managed code</em> only. There are no such concepts in the <em>unmanaged </em>world. Everything is "native" in <em>unmanaged code.</em>.. but the types are not referred to "native types" as such. Again, simply put, a <em>Managed type&nbsp;</em>is a type that is defined with the "ref" keyword (ManagedType in Listing 1 below, for example). A <em>Native type&nbsp;</em>is the one that is declared without the "ref" keyword (NativeType in Listing 2, for example).</span><br /><span id="ArticleContent"><em>Managed types</em> are allocated on managed stack or managed heap. <em>Native types</em> are allocated on native stack or native heap. The managed and native stack are much similar as far as the way memory gets cleaned up. Once the object goes out of scope, the memory is reclaimed. Memory in managed heap is managed by the garbage collector. Memory in native heap is managed by the programmer.</span><br /><h2><span id="ArticleContent">Accessing <em>Managed type</em> from <em>Native type</em>&nbsp;</span></h2><span id="ArticleContent">First, lets briefly see how to access a managed type from a native type, but the main purpose of this post is to see how one can access a managed type from purely <em>unmanaged code</em> (compiled without /clr). The method is sort of explained here (http://msdn.microsoft.com/en-us/magazine/cc300632.aspx) but I found it somewhat difficult to follow so here is my attempt to simplify it a little.&nbsp;</span><br /><span id="ArticleContent">As an example, lets invoke the DoSomething method of ManagedType from NativeType, and then invoke the same method from a global UnmanagedFunction (see Listing 6)&nbsp;</span><br /><br /><pre><span id="ArticleContent">Listing 1 - ManagedType.h<br /><br />public ref class ManagedType<br />{<br />   void DoSomething();<br />}; &nbsp;</span></pre><pre><br /></pre><span id="ArticleContent">To use the ManagedType from NativeType, one could simply try to include the reference type as a member of native type as shown in Listing 1.1 below. It will cause a compiler error. Native types are allocated on native stack/heap but managed types are not. Including a managed type as a member would mean that it will also get allocated on the native stack/heap, which would violate the C++/CLI design.</span><br /><br /><pre><span id="ArticleContent">Listing 1.1 - NativeType.h<br /><br />class NativeType<br />{<br /> public:<br />     ManagedType^ managedType; // error...not allowed<br />}&nbsp;</span></pre><pre><br /></pre><span id="ArticleContent">Operator overloads make its use much the same as the underlying managed type it wraps. See the implementation of NativeType in Listing 3, for example.</span><br /><br /><pre><span id="ArticleContent">Listing 2 - NativeType.h<br /><br />#include &lt;vcclr.h&gt;<br /><br />class NativeType<br />{<br /> public:<br />   NativeType();<br />   ~NativeType();<br /><br />   void proxy();<br />   gcroot&lt;ManagedType^&gt; virtualManagedType;<br />}&nbsp;&nbsp;</span></pre><pre><span id="ArticleContent">Listing 3 - NativeType.cpp (compile with /clr)<br /><br />#include "NativeType.h"<br /><br />NativeType::NativeType()<br />{<br />   //one way of assigning managed reference to gcroot&lt;T&gt; handle<br />   virtualManagedType = gcnew ManagedType();<br />}<br /><br />void NativeType::proxy()<br />{<br />   if (virtualManagedType)<br />   {<br />     virtualManagedType-&gt;DoSomething();<br />   }<br />}&nbsp;</span></pre><pre><br /></pre><span id="ArticleContent">As you can see virtualManagedType can be treated just the same as a reference to ManagedType.&nbsp;</span><br /><h2><span id="ArticleContent">Accessing <em>Managed type</em> from <em>Unmanaged code&nbsp;&nbsp;</em></span></h2><span id="ArticleContent">Now, lets see how to access the ManagedType from <em>unmanaged code. </em>It&nbsp;has no idea of what ManagedType is, but how about a NativeType? After all, isn't <em>native type</em> a simple C/C++ type albeit compiled with /clr ? The answer is <em>not really</em>...&nbsp;</span><br /><br /><pre><span id="ArticleContent">Listing 4 - UnmanagedCode.cpp (compile without /clr)<br /><br />#include "NativeType.h" // error...<br />...&nbsp;</span></pre><pre><br /></pre><span id="ArticleContent">Doing so produces an error. The reason is the gcroot&lt;T&gt; member of NativeType. Remember that it wraps GCHandle which is a <em>managed type</em>, and <em>unmanaged code</em> has no idea of what that means.&nbsp;</span><br /><span id="ArticleContent">Here, we can use the _MANAGED precompiler directive and intptr_t to trick the <em>unmanaged code </em>&nbsp;into believing that the referenced type&nbsp;is an&nbsp;<em>integer&nbsp;</em>type (<em>unmanaged code)</em><em>&nbsp;</em>called intptr_t. _MANAGED is set when the compilation mode is /clr. We wrap the gcroot&lt;T&gt; handle in _MANAGED to make it invisible to unmanaged code, and expose an intptr_t instead.</span><br /><br /><pre><span id="ArticleContent">Listing 5 - NativeType.h<br /><br />#include &lt;vcclr.h&gt;<br /><br />class NativeType<br />{<br />  public:<br />    NativeType();<br />    ~NativeType();<br /><br />    void proxy();<br /><br />    #ifdef _MANAGED<br />      gcroot&lt;ManagedType^&gt; virtualManagedType;<br />    #else<br />      intptr_t virtualManagedType;<br />    #endif<br /><br />}&nbsp;</span></pre><pre><br /></pre><span id="ArticleContent">We can replace the gcroot&lt;T&gt; handle with intptr_t because the memory semantics for both are exactly the same. The intptr_t (http://msdn.microsoft.com/en-us/library/323b6b3k.aspx) is simply an integer whose size is either 32-bit or 64-bit depending on the platform. The gcroot&lt;T&gt; has a void pointer (void* _handle) as its only data member, which is also 32-bit or 64-bit integer depending on the platform.&nbsp;</span><br /><span id="ArticleContent">Now, we can simply include NativeType.h anywhere and use NativeType&nbsp;</span><br /><br /><pre><span id="ArticleContent">Listing 6 - UnmanagedCode.cpp (compile without /clr)<br /><br />#include "NativeType.h"<br /><br />void UnmanagedFunction()<br />{<br />   NativeType nativeType;<br />   nativeType.proxy(); // calls ManagedType::DoSomething()<br />}</span></pre><pre><br /></pre><span id="ArticleContent">Its important to keep it in mind that what we did with the _MANAGED and intprt_t is just a trick to get the unmanaged code to "know" about the a member of NativeType called virtualManagedType that occupies a certain size memory, so that it can compile and link correctly. In both cases, the linker links to the same implementation of NativeType which is in fact managed code (remember it is /clr compiled)&nbsp;&nbsp;</span><br /><div><span id="ArticleContent"><span style="font-size: 12px; white-space: pre;"></span></span><br /><br /><br /><br /><br /><span id="ArticleContent"><br /><br /></span></div><!-- End Article -->  </div></td></tr></tbody></table></td></tr></tbody></table></div>